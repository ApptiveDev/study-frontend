## 조사 1
+ *C*lient *S*ide *R*endering: 웹 페이지의 콘텐츠를 클라이언트(브라우저)에서 렌더링*하는 방식. 서버에서 HTML, CSS, Javascript 파일을 클라이언트로 보내고, 클라이언트에서 Javascript를 실행하여 동적인 웹 페이지 생성. => 서버의 부하 감소, interactive한 기능 제공 가능
    + 과정) 서버로부터 HTML, JS  파일 다운로드 -> SPA 프레임웤, 실행 -> 페이지 보여지고 상호 작용에 따라 필요한 데이터 서버에 요청
    + 장) 페이지 전체 요청 X 변화된 부분만 재렌더링 진행 -> SSR 보다 빠른 interaction 가능<br>
        lazy loading(페이지 내에서 바로 필요하지 않은 데이터는 로딩 X 필요한 시점에 로딩) 지원
    + 단) 초기 로딩 오래 걸릴 수 있음, 검색 엔진 최적화 (SEO) 어려움

+ *S*erver *S*ide *R*endering: 서버에서 html, js를 만들고 렌더링을 모두 서버에서 진행하고 클라이언트(브라우저)에 넘겨주는 방식. 
    + 과정) 렌더링된 HTML 응답 -> 페이지 보여지고 JS 다운로드 -> SPA 프레임워크 실행 및 상호 작용에 따라 필요한 데이터 요청
    + 장) 초기 로딩 빠름, html의 바디에 content가 담겨있어 CSR보다 SEO에 적합
    + 단) 완전히 새로 렌더링함, 서버 과부화 발생 가능, interaction 못하는 경우 발생 가능

*렌더링: HTML, CSS, Javascript로 작성된 문서를 해석하여 브라우저에 시각적으로 출력하는 것

## 조사 2
+ 선언적 -> WHAT: *무엇을 해결할 것인지*에 집중하여 어떻게 문제를 해결하는지에 대해서는 컴퓨터에 위임하는 방법. 목표 명시 O, 알고리즘 명시 X
+ 명령형 -> HOW : *문제를 어떻게 해결해야하는지* 컴퓨터에게 명시적으로 명령을 내리는 방법. <br> 알고리즘 명시 O, 목표 명시 X

=> 선언적 방식의 접근을 위해선 명령형 방식으로 어떻게 접근하는가에 관한 내용이 먼저 추상화 되어 있어야 함 

## 조사 3
1. URL 입력 및 요청청
    + 사용자가 브라우저에 URL 입력 -> 브라우저가 DNS 서버에 해당 도메인의 IP 주소 요청
    + IP 주소 얻으면 해당 웹 서버로 HTTP(S) 요청

2. 서버 응답 및 HTML 다운로드
    + 웹 서버: 요청 처리, 응답으로 HTML 파일 반환
    + HTTP 상태 코드 함께 전송
    + 브라우저: HTML 해석하며 필요한 추가 리소스 요청

3. HTML 파싱* 및 DOM 생성
    + HTML 파일을 파싱하여 DOM(Document Object Model) 트리 생성
    + HTML 태그가 계층 구조로 변환, 각 요소를 객체로 표현
    + 이 과정에서 script 태그를 만나면 기본적으로 JS를 실행하기 위해 파싱을 멈추고, 실행 후 다시 진행

4. CSS 파싱 및 CSSOM 생성
    + CSS 파일이 로드되면 브라우저는 이를 파싱하여 CSSOM(CSS Object Model) 트리 생성
    + DOM과 CSSOM 결합하여 Render Tree 생성

5. Render Tree 생성
    + Render Tree: 실제 화면에 표시될 요소들만 포함 (display: none; 등으로 숨겨진 요소 제외), 각 요소의 스타일과 레이아웃 정보 반영

6. 레이아웃 계산 (Layout, Reflow)
    + 각 요소의 크기와 위치 계산하여 화면 배치 정보 결정
    + 부모 요소의 크기나 위치가 변하면 자식 요소도 영향 받아 다시 계산 가능

7. 페인트(Painting)
    + 각 요소의 색상, 이미지, 텍스트 등을 픽셀로 변환하여 화면에 렌더링
    + 이 과정에서 GPU 활용하여 최적화 가능

8. 합성 (Compositing)
    + 여러 레이어가 있으면 합쳐서 최종 화면 구성
    + CSS transform, opacity, will-change 등의 속성: 레이어 분리를 유도하여 성능 개선 가능

*파싱: 일련의 문자열로 이루어진 입력을 토큰이나 트리와 같은 구조로 변환하는 과정. 입력을 분석하여 구조적인 정보를 추출하고 해석함.

## 조사 4
+ 컴포넌트 기반 구조: UI를 독립적인 컴포넌트 단위로 나누어 개발, 재사용성 뛰어나 유지 보수 및 확장성 높아짐짐
+ 가상 DOM 사용: DOM의 복사본을 가상 DOM에 저장하고 변화가 필요한 부분만 일부 수정하는 방식으로 불필요한 화면의 갱신 최소화, 성능 향상 (기존: 변화 발생 시 전체 DOM 새로 그려냄냄)
+ 데이터 흐름 예측 가능
+ 모바일 앱 개발까지 이용 가능
