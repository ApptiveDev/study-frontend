
## 조사 1
+ 단일 책임 원칙: 하나의 컴포넌트는 하나의 기능만 수행
+ 재사용성: 여러 곳에 재사용 가능 -> 별도의 컴포넌트로 분리
+ 가독성: 작고 독립적인 컴포넌트로 코드를 나누면 각 부분의 기능 명확, 에러 찾기 쉬움, 전체 구조 이해 쉬워져 코드의 가독성 높아짐 -> 프로그램의 이해를 돕고 다른 개발자가 코드를 더 쉽게 읽고 수정 가능
+ 상태와 라이프사이클: 컴포넌트는 자신의 상태를 내부적으로 관리 가능, 상태 변화에 따라 적절한 라이프사이클 메소드 호출 -> 이러한 메소드는 컴포넌트가 화면에 렌더링되기 전 후, 업데이트 되기 전 후, 제거되기 전에 실행되는 코드 정의
+ UI 요소: 다양한 UI 요소를 별도의 컴포넌트로 분리 시, 각 요소가 독립적으로 개발되고 테스트될 수 있음 -> UI의 일관성 유지, 복잡성 관리에 도움

**생명주기 메소드: 컴포넌트가 생성, 업데이트, 삭제되는 과정에서 특정 시점에 호출되는 메소드

## 조사 2
+ 복잡한 문법과 생명주기 관리: 클래스형 컴포넌트는 상속 구조 사용, 복잡한 생명 주기 메서드 포함 -> 컴포넌트의 이해와 유지보수 어려움
+ 코드의 가독성과 간결성: 클래스형 컴포넌트는 constructor, render 메서드 등의 추가적 문법 요구, this 키워드 사용 -> 코드의 가독성과 간결성 저하
+ 성능: 클래스형 컴포넌트는 더 많은 메모리 사용, 인스턴스 생성 시 추가 비용 발생, 클래스형 컴포넌트는 바인딩과 메서드 호출에 대한 오버헤드 있을 수 있음
+ 함수형 컴포넌트와 훅의 도입: 함수형은 클래스형과 비교하여 간단하고 명확한 문법 가짐, 훅을 통해 상태 관리와 생명주기 기능 활용 가능 -> 함수형 컴포넌트와 훅 선호 
+ 더 나은 추상화와 컴포넌트 재사용성: 함수형은 순수 함수처럼 동작하고 렌더링 결과를 반환하는 형태로 작성됨 -> 더 나은 추상화 제공, 컴포넌트의 재사용성 높임

## 조사 3
+ 에러 바운더리 구현 시
+ 특정 생명주기 메서드 필요 시
+ 레거시 코드 유지보수 시
+ 일부 타사 라이브러리와의 통합 시

## 조사 4
+ 컴포넌트를 트리 구조로 배치할 때, 한 컴포넌트가 다른 컴포넌트를 포함 -> 부모-자식 관계 성립

## 조사 5
+ 필요한 이유
++ 리스트를 렌더링할 때 각 항목의 변경, 추가, 삭제를 효율적으로 식별하기 위해 key 사용
++ key 값 없으면 불필요한 리렌더링 또는 잘못된 DOM 조작 발생 가능
+ key 값 정하는 기준
++ 고유하고 안정적인 값
++ 일반적으로 각 항목의 id 값이나 고유 식별자 사용
++ 인덱스는 변경되지 않는 리스트일 때만 사용 <- 항목의 순서 변경 가능의 경우 성능이 저하되거나 컴포넌트의 state 관련 문제 발생 가능

## 조사 6
+ 조건부 렌더링: 조건에 따라 특정 UI를 보여주거나 숨기는 것
+ 언제 사용?
++ 로그인 여부에 따라 다른 화면 보여줄 때
++ 데이터가 로딩 중일 때 표시
++ 에러 발생 시 에러 메시지 표시